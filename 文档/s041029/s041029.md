# 四组项目情况展示

注：

	1. 请结合目录或大纲查看本文档。
 	2. 只列出发生变动的内容和新增的内容。


[TOC]

## 一、补充定义

本周内进行了一些增量开发，下面是相关说明

### 1. Search类定义

#### (1). Search类介绍

​	考虑到对底层树形结构进行直接遍历的时间复杂度较高（约为O(n^2)），使用Search类创建简单的有序索引文件，以方便存取。Search类建立fmindex/fISBNindex+fnameindex+fauthorindex文件，存储每一个数据的关键字（id）及对应的部分值。完成对database类的增删改查后，在**退出系统时**运行。

存储形式：8个字节的ID+	x字节的数据项（fmindex.txt)

​												6字节的数据项（fISBNindex.txt)

​												8字节的数据项（fnameindex.txt)

​												4字节的数据项（fauthorindex.txt）

#### (2). 定义

```C++
class Search
{
public:
	//构造函数
	Search();
	//生成索引表，格式为[id 索引项],id为8位整数按二进制字符存储、索引项形式为字符串
	bool indexFile_Create();
	//indexFile_Create()的变种，生成的索引项为一个字符串（位数截取）
	bool indexFile_Create_mod(string mod);
	//indexFile_Create()的变种，生成的索引项为字符串中自str_min起长度为str_len的部分
	bool indexFile_Create_mod(int str_min, int str_len);
	//调用函数
	bool indexFile_Traverse();
	//调用函数的变种，给定索引项的类型
	bool indexFile_Traverse(string mod);
	//调用函数的变种，给定索引项在字符串中的起始位置与长度
	bool indexFile_Traverse(int str_min, int str_len);
	//遍历函数，对database中所有数据读取到内存
	bool indexFile_Search();
	//初始化函数，确定database中数据关键字的范围（严格单调）
	bool indexFile_Init();
	~Search();
private:
	int max_key;//最大关键字
	int min_key;//最小关键字
	vector<int>id;//id容器
	vector<string>value;//value字符串容器
};
```



#### (3). 实现

indexFile_Init()函数：判断树（实际是index文件）中最小的key和最大的key（关键字）

```C++
bool Search::indexFile_Init() {
	string value;
	while (!database.select(min_key, value)) min_key++;
	while (!database.select(max_key, value)) max_key--;
	return true;
}
```

indexFile_Search()函数：遍历树，将每一个(id,value)分别放入容器id，value。

```C++
bool Search::indexFile_Search() {
	string v;
	try {
		for (int i = min_key; i < max_key; i++) {
			if (database.select(i, v)) {
				id.push_back(i);
				value.push_back(v);
			}
		}
	}
	catch (std::out_of_range& exc) {
		std::cerr << exc.what() << endl;
		return false;
	}
	return true;
}
```

indexFile_Create()函数：将id与value两个vector容器中的内容逆序存入fintex.txt文件中。


```C++
bool Search::indexFile_Create() {//全字符串版本
	ofstream findex("findex.txt", ios::binary);
	string data_id;
	string data_value;
	while (!id.empty()) {
		data_id = to_string(id.back());
		id.pop_back();
		data_value = value.back();
		value.pop_back();
		findex.write(data_id.c_str(), LENGTH_ID);
		findex.write(data_value.c_str(), LENGTH_VALUE);
	}
	findex.close();
	return true;
}
```

indexFile_Create_mod(string mod)函数：indexFile_Create()函数的衍生，将id与value两个vector容器中的内容逆序存入f+“mod”+intex.txt文件中，但每个value只截取mod对应的部分，比如ISBN，name，author。注：vector容器读写，遇到空字符会发生std::out_of_range错误。所以需要确保读取到的字符串不为空串（否则会终止生成）。

```C++
bool Search::indexFile_Create_mod(string mod) {
	string data_id;
	string data_value;
	try {
		if (mod == "ISBN") {
			ofstream fmindex("fISBNindex.txt", ios::binary);
			while (!id.empty()) {
				data_id = to_string(id.back());
				id.pop_back();
				data_value = value.back().substr(START_ISBN, LENGTH_ISBN);
				value.pop_back();
				fmindex.write(data_id.c_str(), LENGTH_ID);
				fmindex.write(data_value.c_str(), LENGTH_ISBN);
				fmindex.close();
			}
		}
		if (mod == "name") {
			ofstream fmindex("fnameindex.txt", ios::binary);
			while (!id.empty()) {
				data_id = to_string(id.back());
				id.pop_back();
				data_value = value.back().substr(START_NAME, LENGTH_NAME);
				value.pop_back();
				fmindex.write(data_id.c_str(), LENGTH_ID);
				fmindex.write(data_value.c_str(), LENGTH_NAME);
				fmindex.close();
			}
		}
		if (mod == "author") {
			ofstream fmindex("fauthorindex.txt", ios::binary);
			while (!id.empty()) {
				data_id = to_string(id.back());
				id.pop_back();
				data_value = value.back().substr(START_AUTHOR, LENGTH_AUTHOR);
				value.pop_back();
				fmindex.write(data_id.c_str(), LENGTH_ID);
				fmindex.write(data_value.c_str(), LENGTH_AUTHOR);
				fmindex.close();
			}
		}
	}
	catch (std::out_of_range& exc) {//遇到空字符时，读取失败
		std::cerr << exc.what() << endl;
		return false;
	}
	return true;
}
```

indexFile_Create_mod(int str_min, int str_len)函数：indexFile_Create()函数的衍生，将id与value两个vector容器中的内容逆序存入fmintex.txt文件中，同时每个value只截取第str_min位到第str_len位。

```C++
bool Search::indexFile_Create_mod(int str_min, int str_len) {
	ofstream fmindex("fmindex.txt", ios::binary);
	string data_id;
	string data_value;
	while (!id.empty()) {
		data_id = to_string(id.back());
		id.pop_back();
		data_value = value.back().substr(str_min, str_len);
		value.pop_back();
		fmindex.write(data_id.c_str(), LENGTH_ID);
		fmindex.write(data_value.c_str(), str_len);
	}
	fmindex.close();
	return true;
}
```

indexFile_Traverse()函数：调用上述函数。在main文件中使用。

```C++
bool Search::indexFile_Traverse() {
	indexFile_Init();
	indexFile_Search();
	indexFile_Create();
	return true;
}
```

```C++
bool Search::indexFile_Traverse(string mod) {
	indexFile_Init();
	if (indexFile_Search())
		cout << "Search Successfully." << endl;
	else
		cout << "Search Failed" << endl;
	if (indexFile_Create_mod(mod)) {
		cout << "FastIndex create successfully." << endl;
		return true;
	}
	else
	{
		cout << "FastIndex create failed." << endl;
		return false;
	}
}

```

```C++
bool Search::indexFile_Traverse(int str_min, int str_len) {
	indexFile_Init();
	if (indexFile_Search())
		cout << "Search Successfully." << endl;
	else
		cout << "Search Failed" << endl;
	if (indexFile_Create_mod(str_min, str_len)) {
		cout << "FastIndex create successfully." << endl;
		return true;
	}
	else
	{
		cout << "FastIndex create failed." << endl;
		return false;
	}
}
```

#### (4). 调试

![VsDebugConsole_[44] 2020-10-25 19_50_57](.\VsDebugConsole_[44] 2020-10-25 19_50_57.png)

### 2. bookdocking类补充定义

​	对bookdocking类中的bookdocking()、bookadd()、bookdelete()三个函数进行了重载。此部分尚未进行对接与调试。

```C++
bookdocking::bookdocking(string mod){
	blank_str = string(LENGTH_ID + LENGTH_VALUE, ' ');
	firstEmpty = 0;//firstEmpty shows the first empty destination to store new datas when new data is inputed
	zero_str = "0000";//zero_str is a string to rewrite the address in fEmpty to change the isEmpty information
}


bool bookdocking::bookadd(string mod,int id,string ISBN, string name, string author, string type, string borrowtime, string returntime, string histroy, string onsheelf, string isovertime)
{	
	to_id = to_string(id);
	value = ISBN + name + author + type + borrowtime + returntime + histroy + onsheelf + isovertime;
	to_value = value;
	if (database.insert(id, value)) {
		fEmpty.open("fEmpty.txt", ios::binary); //open the file that indicates the empty place in the datafile fIndex
		if (fEmpty.peek() != EOF) {//check if the fEmpty file is not an empty one. if so, execute the following codes.
			fData.open("fIndex.txt", ios::binary);//open the file fIndex to add items
			fEmpty.seekg(0, ios::beg);//go to the head of the fEmpty
			getline(fEmpty, v_index);//read a line (serves as an address (4 bytes data per line), indicates an empty in fIndex
			while (!atoi(v_index.c_str())) {	//find the first non-zero destination of fEmpty
				firstEmpty = fEmpty.tellg();//store the present destination that the file pointer fEmpty points, in file fEmpty(read)
				getline(fEmpty, v_index);//id not non-zero, read a new data (in a new line)
			}
			fData.seekp(atoi(v_index.c_str()), ios::beg);//move the pointer fData to the empty destination
			//fEmpty.read(c_to_str.c_str(), 4);
			fData.write(to_id.c_str(), LENGTH_ID);//write the id data (within 8(?) bytes) into the fIndex
			fData.write(to_value.c_str(), LENGTH_VALUE);//write the value data (within 80 bytes) into the fIndex, whithout any blanks between id data
			fData.write("\n", sizeof(char));//start a new line in fIndex for another new datas
			fEmpty.seekp(firstEmpty, ios::beg);//go to the empty place indicated in fEmpty
			fEmpty.write(zero_str.c_str(), LENGTH_INDEXADDRESS);//change the address data to 0000(if trans to int, is 0)
			fData.close();
			fEmpty.close();
			return true;
		}
		else {//if the fEmpty is empty, execute the following codes
			fData.open("fEmpty.txt", ios::binary | ios::app);//no free spaces to write on, so start a new line at the rear of the file
			fData.write(to_id.c_str(), LENGTH_ID);//write id data
			fData.write(to_value.c_str(), LENGTH_VALUE);//write value data
			//no changes in fEmpty, so no need to change it.
			fData.close();
			fEmpty.close();
			return true;
			//fEmpty.write();
		}
	}
	else
		return false;

}
bool bookdocking::bookdelete(string mod,int id) {
	if (database.remove(id)) {
		fEmpty.open("fEmpty.txt", ios::binary);
		fData.open("fIndex.txt", ios::binary);
		address = search(id);// get the correct destination the fIndex stores that line of data (return the address of it.)
		v_index = to_string(address);//transform the address(int) to string
		fData.seekp(address, ios::beg);//move the pointer of fData to the place of address
		fData.write(blank_str.c_str(), LENGTH_ID + LENGTH_VALUE);//replace the datas with a blank string (88 bytes, a line).
		if (fEmpty.peek() == EOF) {//if fEmpty is empty
			fEmpty.seekp(0, ios::beg);
			fEmpty.write(v_index.c_str(), LENGTH_INDEXADDRESS);//write the position data into the fEmpty
			// not [fEmpty.write(new_str.c_str(), LENGTH_INDEXADDRESS);]!!!!
		}
		else {//fEmpty is not empty
			/*
			fEmpty.seekp(0, ios::beg);
			getline(fEmpty, new_str);
			while (atoi(new_str.c_str()) != address) {
				firstEmpty = fEmpty.tellg();
				getline(fEmpty, new_str);
				}
			fEmpty.seekp(firstEmpty, ios::beg);
			fEmpty.write(zero_str.c_str(),LENGTH_INDEXADDRESS);
			*/
			fEmpty.seekp(0, ios::beg);
			getline(fEmpty, new_str);
			while (!atoi(new_str.c_str()))//while new_str receives "0000" (0 in int), keep traversing for the next line
			{
				firstEmpty = fEmpty.tellg();
				getline(fEmpty, new_str);
			}
		}
		return true;
	}
	else
		return false;
}
```

## 二、进度展示

### 1. 底层进度

​	目前的底层部分已经能实现各个功能。

​	![Microsoft_Visual_Studio_调试控制台 [70] 20-10-29 09_14_28](.\Microsoft_Visual_Studio_调试控制台 [70] 20-10-29 09_14_28.png)

（以上仅为试运行，底层功能已经实现）

运行后的数据文件内容（二进制形式存储）：

![data_-_记事本 [71] 20-10-29 09_24_56](.\data_-_记事本 [71] 20-10-29 09_24_56.png)

运行后的索引文件内容：

![index.txt.hexdump_-_Visual_Studio_Code [72] 20-10-29 09_25_03](.\index.txt.hexdump_-_Visual_Studio_Code [72] 20-10-29 09_25_03.png)

（有关存储形式的约定，参见之前的s041014与s041022文档）